<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Podcast App</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacStystemFont, 'Segoe U I', Roboto, sans-serif;
}
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            background: linear-gradient(135deg, #6e8efb, #a777e3);
            color: white;
            padding: 2rem 0;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .loading, .error, .empty {
            text-align: center;
            padding: 3rem;
            font-size: 1.2rem;
        }

        .loading {
            color: #6e8efb;
        }

        .error {
            color: #e74c3c;
        }

        .empty {
            color: #7f8c8d;
        }

        /* Controls Section */
        .controls {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            margin-bottom: 2rem;
            display: grid;
            grid-template-columns: 1fr auto auto auto;
            gap: 1rem;
            align-items: end;
        }

        .search-box {
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 0.8rem 1rem 0.8rem 2.5rem;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #6e8efb;
        }

        .search-icon {
            position: absolute;
            left: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            color: #7f8c8d;
        }

        .filter-select, .sort-select {
            padding: 0.8rem 1rem;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
            min-width: 150px;
        }

        .filter-select:focus, .sort-select:focus {
            outline: none;
            border-color: #6e8efb;
        }

        .reset-btn {
            padding: 0.8rem 1.5rem;
            background: #6e8efb;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .reset-btn:hover {
            background: #5a7dfa;
        }

        .results-info {
            margin-bottom: 1rem;
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .podcasts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 2rem;
            padding: 0 1rem 2rem;
        }

        .podcast-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
        }

        .podcast-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        .podcast-image {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-bottom: 1px solid #eee;
        }

        .podcast-info {
            padding: 1.5rem;
        }

        .podcast-title {
            font-size: 1.3rem;
            margin-bottom: 0.8rem;
            color: #2c3e50;
        }

        .podcast-details {
            margin-bottom: 1rem;
        }

        .podcast-seasons, .podcast-updated {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-bottom: 0.5rem;
        }

        .podcast-genres {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .genre-tag {
            background: #e0e7ff;
            color: #4f46e5;
            padding: 0.3rem 0.7rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .pagination-btn {
            padding: 0.5rem 1rem;
            border: 2px solid #e0e7ff;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .pagination-btn:hover:not(:disabled) {
            background: #6e8efb;
            color: white;
            border-color: #6e8efb;
        }

        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination-info {
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .page-numbers {
            display: flex;
            gap: 0.5rem;
        }

        .page-number {
            padding: 0.5rem 0.8rem;
            border: 2px solid #e0e7ff;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .page-number.active {
            background: #6e8efb;
            color: white;
            border-color: #6e8efb;
        }

        .page-number:hover:not(.active) {
            background: #f0f4ff;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid #eee;
        }

        .modal-header h2 {
            font-size: 1.8rem;
            color: #2c3e50;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: #7f8c8d;
            transition: color 0.2s;
        }

        .close-btn:hover {
            color: #e74c3c;
        }

        .modal-body {
            padding: 1.5rem;
        }

        .modal-banner {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .modal-img {
            width: 250px;
            height: 250px;
            object-fit: cover;
            border-radius: 8px;
            flex-shrink: 0;
        }

        .modal-info {
            flex: 1;
        }

        .modal-info h3 {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }

        .modal-info p {
            margin-bottom: 1.5rem;
            color: #555;
        }

        .season-list {
            list-style: none;
            margin-top: 1rem;
        }

        .season-item {
            padding: 1rem;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .season-item:last-child {
            border-bottom: none;
        }

        .season-title {
            font-weight: 600;
            color: #2c3e50;
        }

        .episodes {
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        footer {
            text-align: center;
            padding: 2rem 0;
            margin-top: 2rem;
            color: #7f8c8d;
            border-top: 1px solid #eee;
        }



        </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

         /**
         * Genre mapping from data.js
         * Maps genre IDs to their corresponding titles
         * @type {Object}
         */
         const genreMap = {
            1: "Personal Growth",
            2: "Investigative Journalism",
            3: "History",
            4: "Comedy",
            5: "Entertainment",
            6: "Business",
            7: "Fiction",
            8: "News",
            9: "Kids and Family"
        };

        /**
         * Format date to relative time string
         * @param {string} dateString - ISO date string
         * @returns {string} Formatted relative time string
         */
        const formatDate = (dateString) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffTime = Math.abs(now - date);
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) return 'today';
    if (diffDays === 1) return 'yesterday';
    if (diffDays < 7) return `${diffDays} days ago`;
    if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
    if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
    return `${Math.floor(diffDays / 365)} years ago`;
}; 

/**
         * Podcast Preview Card Component
         * Displays individual podcast information in a card format
         * @param {Object} props - Component props
         * @param {Object} props.podcast - Podcast data object
         * @param {Function} props.onClick - Click handler function
         */
         const PodcastPreviewCard = ({ podcast, onClick }) => {
            const handleKeyPress = (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    onClick(podcast);
                }
            };

            return (
                <div 
                    className="podcast-card" 
                    onClick={() => onClick(podcast)}
                    onKeyPress={handleKeyPress}
                    tabIndex={0}
                    role="button"
                    aria-label={`View details for ${podcast.title}`}
                >
                    <img 
                        src={podcast.image} 
                        alt={podcast.title}
                        className="podcast-image"
                        onError={(e) => {
                            e.target.src = 'https://place-hold.it/300x200/6e8efb/ffffff&text=Podcast&fontsize=16';
                        }}
                    />
                    <div className="podcast-info">
                        <h3 className="podcast-title">{podcast.title}</h3>
                        <div className="podcast-details">
                            <p className="podcast-seasons">{podcast.seasons} season{podcast.seasons !== 1 ? 's' : ''}</p>
                            <p className="podcast-updated">Updated {formatDate(podcast.updated)}</p>
                        </div>
                        <div className="podcast-genres">
                            {podcast.genres.map(genreId => (
                                <span key={genreId} className="genre-tag">
                                    {genreMap[genreId] || 'Unknown'}
                                </span>
                            ))}
                        </div>
                    </div>
                </div>

            );

        };

        /**
         * Modal Component for detailed podcast view
         * @param {Object} props - Component props
         * @param {Object} props.podcast - Selected podcast data
         * @param {boolean} props.isOpen - Modal open state
         * @param {Function} props.onClose - Close handler function
         */
         const PodcastModal = ({ podcast, isOpen, onClose }) => {
            if (!isOpen || !podcast) return null;
            
            // Mock season data
            const mockSeasons = Array.from({length: podcast.seasons}, (_, i) => ({
                title: `Season ${i + 1}`,
                episodes: Math.floor(Math.random() * 10) + 5
            }));

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <div className="modal-header">
                            <h2>{podcast.title}</h2>
                            <button className="close-btn" onClick={onClose} aria-label="Close modal">
                                &times;
                            </button>
                        </div>
                        <div className="modal-body">
                            <div className="modal-banner">
                                <img 
                                    src={podcast.image} 
                                    alt={podcast.title}
                                    className="modal-img"
                                    onError={(e) => {
                                        e.target.src = 'https://place-hold.it/300x300/6e8efb/ffffff&text=Podcast&fontsize=16';
                                    }}
                                />
                                <div className="modal-info">
                                    <h3>Description</h3>
                                    <p>{podcast.description}</p>
                                    <h3>Genres</h3>
                                    <div className="podcast-genres">
                                        {podcast.genres.map(genreId => (
                                            <span key={genreId} className="genre-tag">
                                                {genreMap[genreId] || 'Unknown'}
                                            </span>
                                        ))}
                                    </div>
                                    <p className="podcast-updated">Updated {formatDate(podcast.updated)}</p>
                                </div>
                            </div>
                            <h3>Seasons</h3>
                            <ul className="season-list">
                                {mockSeasons.map((season, index) => (
                                    <li key={index} className="season-item">
                                        <span className="season-title">{season.title}</span>
                                        <span className="episodes">{season.episodes} episodes</span>
                                    </li>
                                ))}
                            </ul>
                        </div>
                    </div>
                </div>
            );
        };

        /**
         * Controls Component for search, filter, and sort functionality
         * @param {Object} props - Component props
         */
         const Controls = ({ searchTerm, onSearchChange, selectedGenre, onGenreChange, sortBy, onSortChange, onReset }) => {
            return (
                <div className="controls">
                    <div className="search-box">
                        <span className="search-icon">🔍</span>
                        <input
                            type="text"
                            placeholder="Search podcasts by title..."
                            value={searchTerm}
                            onChange={(e) => onSearchChange(e.target.value)}
                            className="search-input"
                            aria-label="Search podcasts"
                        />
                    </div>
                    
                    <select 
                        value={selectedGenre} 
                        onChange={(e) => onGenreChange(e.target.value)}
                        className="filter-select"
                        aria-label="Filter by genre"
                    >
                        <option value="">All Genres</option>
                        {Object.entries(genreMap).map(([id, name]) => (
                            <option key={id} value={id}>{name}</option>
                        ))}
                    </select>
                    
                    <select 
                        value={sortBy} 
                        onChange={(e) => onSortChange(e.target.value)}
                        className="sort-select"
                        aria-label="Sort podcasts"
                    >
                        <option value="newest">Newest First</option>
                        <option value="oldest">Oldest First</option>
                        <option value="title-asc">Title A-Z</option>
                        <option value="title-desc">Title Z-A</option>
                    </select>
                    
                    <button onClick={onReset} className="reset-btn">
                        Reset Filters
                    </button>
                </div>
            );
        };

        /**
         * Pagination Component
         * @param {Object} props - Component props
         */
         const Pagination = ({ currentPage, totalPages, onPageChange }) => {
            const getPageNumbers = () => {
                const pages = [];
                const maxVisiblePages = 5;
                
                let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
                let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
                
                if (endPage - startPage + 1 < maxVisiblePages) {
                    startPage = Math.max(1, endPage - maxVisiblePages + 1);
                }
                
                for (let i = startPage; i <= endPage; i++) {
                    pages.push(i);
                }
                
                return pages;
            };

            return (
                <div className="pagination">
                    <button 
                        onClick={() => onPageChange(currentPage - 1)}
                        disabled={currentPage === 1}
                        className="pagination-btn"
                        aria-label="Previous page"
                    >
                        Previous
                    </button>
                    
                    <div className="page-numbers">
                        {getPageNumbers().map(page => (
                            <button
                                key={page}
                                onClick={() => onPageChange(page)}
                                className={`page-number ${page === currentPage ? 'active' : ''}`}
                                aria-label={`Page ${page}`}
                                aria-current={page === currentPage ? 'page' : undefined}
                            >
                                {page}
                            </button>
                        ))}
                    </div>
                    
                    <button 
                        onClick={() => onPageChange(currentPage + 1)}
                        disabled={currentPage === totalPages}
                        className="pagination-btn"
                        aria-label="Next page"
                    >
                        Next
                    </button>
                    
                    <span className="pagination-info">
                        Page {currentPage} of {totalPages}
                    </span>
                </div>
            );
        };

        /**
         * Main App Component
         * Manages state and orchestrates all functionality
         */
         const App = () => {
            const [podcasts, setPodcasts] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [selectedPodcast, setSelectedPodcast] = useState(null);
            const [isModalOpen, setIsModalOpen] = useState(false);
            
            // Filter and sort state
            const [searchTerm, setSearchTerm] = useState('');
            const [selectedGenre, setSelectedGenre] = useState('');
            const [sortBy, setSortBy] = useState('newest');
            const [currentPage, setCurrentPage] = useState(1);
            const podcastsPerPage = 9;


        /**
             * Fetch podcasts from API
             */
             useEffect(() => {
                const fetchPodcasts = async () => {
                    try {
                        setLoading(true);
                        const response = await fetch('https://podcast-api.netlify.app');
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        
                        if (data && data.length > 0) {
                            setPodcasts(data);
                        } else {
                            setError('No podcasts found in API response');
                        }
                    } catch (err) {
                        console.error('Error fetching podcasts:', err);
                        setError(err.message || 'Failed to load podcasts');
                    } finally {
                        setLoading(false);
                    }
                };

                fetchPodcasts();
            }, []);

            /**
             * Filter, sort, and paginate podcasts based on current state
             */
             const processedPodcasts = useMemo(() => {
                let filtered = podcasts.filter(podcast => {
                    const matchesSearch = podcast.title.toLowerCase().includes(searchTerm.toLowerCase());
                    const matchesGenre = !selectedGenre || podcast.genres.includes(parseInt(selectedGenre));
                    return matchesSearch && matchesGenre;
                });

                // Sort podcasts
                filtered.sort((a, b) => {
                    switch (sortBy) {
                        case 'newest':
                            return new Date(b.updated) - new Date(a.updated);
                        case 'oldest':
                            return new Date(a.updated) - new Date(b.updated);
                        case 'title-asc':
                            return a.title.localeCompare(b.title);
                        case 'title-desc':
                            return b.title.localeCompare(a.title);
                        default:
                            return 0;
                    }
                });

                return filtered;
            }, [podcasts, searchTerm, selectedGenre, sortBy]);

            /**
             * Reset current page when filters change
             */
             useEffect(() => {
                setCurrentPage(1);
            }, [searchTerm, selectedGenre, sortBy]);

            /**
             * Handle podcast card click
             */
             const handlePodcastClick = (podcast) => {
                setSelectedPodcast(podcast);
                setIsModalOpen(true);
            };

            /**
             * Close modal
             */
             const closeModal = () => {
                setIsModalOpen(false);
                setSelectedPodcast(null);
            };

            /**
             * Reset all filters and search
             */
             const handleReset = () => {
                setSearchTerm('');
                setSelectedGenre('');
                setSortBy('newest');
                setCurrentPage(1);
            };

            const totalPages = Math.ceil(processedPodcasts.length / podcastsPerPage);

            return (
                <div>
                    <header>
                        <div className="container">
                            <h1>React Podcast App</h1>
                            <p>Explore and discover podcasts</p>

                        </div>
                    </header>

                    <div className="container">
                        {loading && (
                            <div className="loading">
                                <p>Loading podcasts...</p>
                            </div>
                        )}
                        
                        {error && (
                            <div className="error">
                                <p>Error: {error}</p>
                                <p>Please try again later.</p>
                            </div>
                        )}
                        












    </script>


</body>
</html>